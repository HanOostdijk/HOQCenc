% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/xcode.R
\name{xcode}
\alias{xcode}
\title{Encrypt or decrypt character string}
\usage{
xcode(
  text,
  key = "1VerySecretPasword",
  ed = c("e", "d"),
  trans = "cfcvp",
  noe = FALSE
)
}
\arguments{
\item{text}{Character string or raw vector to encrypt or character string to decrypt}

\item{key}{Character string with encryption/decryption key.
Only the letters (in upper or lower case), digits, the character \verb{#}
and the space are allowed in this key}

\item{ed}{Character (\code{'e'} or \code{'d'} or their upper case versions) that specifies what to do:
\code{'e'} is encrypt, \code{'d'} is decrypt}

\item{trans}{Character string with encrypt/decrypt operations. See \strong{Details}}

\item{noe}{Logical scalar that when set to \code{TRUE} will imit the \code{e} operation. Normally the default value of \code{FALSE}
should be used. See \strong{Details}}
}
\value{
a character string with the encrypted result when \code{ed == 'e'} or
the decrypted result when \code{ed == 'd'}
}
\description{
Encrypt or decrypt character string
}
\details{
Operations in \code{trans} are sequentially executed in the order given for an encrypt
action and in reversed order for the decrypt action.
All operations are working on character strings that contain a multiple of 16 characters.
These characters must belong to the ordered set of the lower case letters, the
upper case letters, digits, the space and the \verb{#} character. This order is changed by the key:
all (non-duplicated) characters from the key are placed before the other characters.

To ensure that all characters belong to this ordered set,
an \code{e} operation is always added (prefixed) to \code{trans} unless \code{noe = TRUE} is used.
\emph{When \code{noe} is set to \code{TRUE} the user must ensure that the string to be encrypted
only contains the characters mentioned above and that the number of characters is
a multiple of 2 when the \code{p} or \code{s} operation is used and a multiple of 16 when the \code{a} operation is used.}

The following operations are defined (we describe only what happens in case of encryption
because for decryption the reversed action is performed):
\itemize{
\item e : encode all characters that are not a blank, a letter or a digit
and ensure that the length of the resulting string is a multiple of 16
\item s : shuffle the characters in such a way that \verb{0123456789abcdef} is translated to \verb{0f2d4b6987a5c3e1}
\item f : flip the characters in such a way that \verb{0123456789abcdef} is translated to \code{fedcba9876543210}
\item v : a Vigenère translation based on the key: the x-th character is shifted in the ordered set
based on the position of the x-th character in the ordered set.
\item c : a Vigenère translation based on the first character of the ordered set for the first character
and from then on based on the result for the preceding character.
\item p : a Playfair translation based on an 8x8 square filled with the ordered set
\item a : an AES translation based on the key. This is in fact the \code{\link[digest:AES]{digest::AES()}} function with \code{mode='ECB'}
\item h : a Hill linear transformation based on the key. This handles 4 consecutive characters
}
}
\examples{
\dontrun{
my_key <- 'Mysecret123'
(s <- xcode('my message!',my_key,ed='e'))
# [1] "8Ge8D3F4Mh1s6q z"
xcode(s,my_key,ed='d')
# [1] "my message!"
}
}
